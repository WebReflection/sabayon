let{SharedArrayBuffer:e}=globalThis,s=!0;try{new e(4,{maxByteLength:8})}catch(t){s=!1,e=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}Promise.withResolvers.bind(Promise);const{isArray:t}=Array,{create:r,defineProperty:a,setPrototypeOf:o}=Object,n=(e,s=!0)=>({configurable:!0,writable:s,value:e}),i=new Map,l=(e,s)=>e[s];const c=new class{constructor(e){this.id=e}handleEvent(s){const{currentTarget:r,data:n}=s;if(((e,s)=>t(e)&&2===e.length&&e[0]===s)(n,this.id)){const{id:t,path:c,value:d}=n[1],u=o(c.reduce(l,d),e.prototype);i.set(u,[t,r]),a(s,"data",{value:d})}}notify({buffer:e},s,t=1/0){const[r,a]=i.get(e);i.delete(e),a.postMessage([this.id,{id:r,value:e}],[e])}}(crypto.randomUUID());let{MessageChannel:d}=globalThis;s||(d=class extends d{constructor(){super().port1.addEventListener("message",c)}});let{Atomics:u,Worker:g}=globalThis;s||(u=r(u,{notify:n(((...e)=>c.notify(...e)))}),g=class extends g{constructor(...e){super(...e),super.addEventListener("message",c),super.postMessage(c.id)}});export{u as Atomics,d as MessageChannel,e as SharedArrayBuffer,g as Worker,s as native};
