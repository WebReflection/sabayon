let{SharedArrayBuffer:e}=globalThis,r=!0;try{new SharedArrayBuffer(4,{maxByteLength:8})}catch(t){r=!1,e=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}const{isArray:t}=Array,{create:s,defineProperty:a,setPrototypeOf:o}=Object,n=(e,r=!0)=>({configurable:!0,writable:r,value:e}),i=new Map,l=(e,r)=>e[r];const c=new class{constructor(e){this.id=e}handleEvent(r){const{currentTarget:s,data:n}=r;if(((e,r)=>t(e)&&2===e.length&&e[0]===r)(n,this.id)){const{id:t,path:c,value:d}=n[1],u=o(c.reduce(l,d),e.prototype);i.set(u,[t,s]),a(r,"data",{value:d})}}notify({buffer:e},r,t=1/0){const[s,a]=i.get(e);i.delete(e),a.postMessage([this.id,{id:s,value:e}],[e])}}(crypto.randomUUID());let{MessageChannel:d}=globalThis;r||(d=class extends d{constructor(){super().port1.addEventListener("message",c)}});let{Atomics:u,Worker:f}=globalThis;r||(u=s(u,{notify:n(((...e)=>c.notify(...e)))}),f=class extends f{constructor(...e){super(...e),super.addEventListener("message",c),super.postMessage(c.id)}});export{u as Atomics,d as MessageChannel,e as SharedArrayBuffer,f as Worker,r as native};
