let{SharedArrayBuffer:e}=globalThis,t=!0;try{new SharedArrayBuffer(4,{maxByteLength:8})}catch(s){t=!1,e=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}const{isArray:s}=Array,{isView:r}=ArrayBuffer,{create:a,defineProperty:n,setPrototypeOf:o}=Object,i=(e,t=!0)=>({configurable:!0,writable:t,value:e}),f=(e,t)=>s(e)&&2===e.length&&e[0]===t,d=e=>{e.stopImmediatePropagation(),e.preventDefault()},l=(t,s)=>async()=>{const r=await s.resolved(t);return n(t,"buffer",i(o(r,e.prototype),!1)),"ok"},c=()=>Promise.withResolvers(),u=new Map,p=(e,t)=>e[t];class g{constructor(e){this.id=e}handleEvent(t){const{currentTarget:s,data:r}=t;if(f(r,this.id)){const{id:a,path:i,value:f}=r[1],d=o(i.reduce(p,f),e.prototype);u.set(d,[a,s]),n(t,"data",{value:f})}}notify({buffer:e},t,s=1/0){const[r,a]=u.get(e);u.delete(e),a.postMessage([this.id,{id:r,value:e}],[e])}}const h=new g(crypto.randomUUID()),y=(t,a,n)=>{if(null!=t&&"object"==typeof t&&!n.has(t)){if(t instanceof e)return{buffer:t,path:a};if(r(t))return n.add(t),y(t.buffer,a.concat("buffer"),n);if(s(t)){n.add(t);for(let e=0;e<t.length;e++){const s=y(t[e],a.concat(e),n);if(s)return s}}else if(!(t instanceof Error)){n.add(t);for(const e in t){const s=y(t[e],a.concat(e),n);if(s)return s}}}};let{MessageChannel:b}=globalThis;t||(b=class extends b{constructor(){super().port1.addEventListener("message",h)}});let{Atomics:v,Int32Array:w,BigInt64Array:A,postMessage:m}=globalThis;if(!t){const{promise:e,resolve:t}=c(),r=new g(""),o=(e=>{const t=new Map,r=new Map;let a=0;return{resolved:({buffer:e})=>t.get(e),listener(s){if(f(s.data,e.id)){d(s);const{id:e,value:a}=s.data[1],{buffer:n,resolve:o}=r.get(e);r.delete(e),t.delete(n),o(a)}},send(n,o,i){const f=y(o,[],new Set);if(f){const{resolve:n,promise:d}=c(),{buffer:l,path:u}=f;((e,t)=>{let r=t.at(-1);switch(typeof r){case"undefined":case"string":t.push([e]);break;default:s(r)?r.push(e):r.transfer?r.transfer.push(e):r.transfer=[e]}})(l,i),o=[e.id,{id:a,path:u,value:o}],t.set(l,d),r.set(a++,{buffer:l,resolve:n})}n(o,...i)}}})(r);addEventListener("message",(e=>{d(e),r.id=e.data,t()}),{once:!0}),addEventListener("message",(e=>{if(e.ports?.length)for(const t of e.ports){const e=t.postMessage.bind(t);t.start(),t.addEventListener("message",o.listener),n(t,"postMessage",i(((t,...s)=>o.send(e,t,s))))}o.listener(e)})),m=(t,...s)=>{r.id.length?o.send(postMessage,t,s):e.then((()=>o.send(postMessage,t,s)))},v=a(v,{waitAsync:i(((t,s,r,a=1/0)=>({async:!0,value:e.then(l(t,o))})))})}export{v as Atomics,A as BigInt64Array,w as Int32Array,b as MessageChannel,e as SharedArrayBuffer,t as native,m as postMessage};
