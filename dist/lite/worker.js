let{SharedArrayBuffer:e}=globalThis,t=!0;try{new SharedArrayBuffer(4,{maxByteLength:8})}catch(s){t=!1,e=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}var s=Promise.withResolvers.bind(Promise);const{isArray:r}=Array,{isView:a}=ArrayBuffer,{create:n,defineProperty:o,setPrototypeOf:i}=Object,f=(e,t=!0)=>({configurable:!0,writable:t,value:e}),d=(e,t)=>r(e)&&2===e.length&&e[0]===t,l=e=>{e.stopImmediatePropagation(),e.preventDefault()},c=(t,s)=>async()=>{const r=await s.resolved(t);return o(t,"buffer",f(i(r,e.prototype),!1)),"ok"},u=new Map,p=(e,t)=>e[t];class g{constructor(e){this.id=e}handleEvent(t){const{currentTarget:s,data:r}=t;if(d(r,this.id)){const{id:a,path:n,value:f}=r[1],d=i(n.reduce(p,f),e.prototype);u.set(d,[a,s]),o(t,"data",{value:f})}}notify({buffer:e},t,s=1/0){const[r,a]=u.get(e);u.delete(e),a.postMessage([this.id,{id:r,value:e}],[e])}}const h=new g(crypto.randomUUID()),y=(t,s,n)=>{if(null!=t&&"object"==typeof t&&!n.has(t)){if(t instanceof e)return{buffer:t,path:s};if(a(t))return n.add(t),y(t.buffer,s.concat("buffer"),n);if(r(t)){n.add(t);for(let e=0;e<t.length;e++){const r=y(t[e],s.concat(e),n);if(r)return r}}else if(!(t instanceof Error)){n.add(t);for(const e in t){const r=y(t[e],s.concat(e),n);if(r)return r}}}};let{MessageChannel:b}=globalThis;t||(b=class extends b{constructor(){super().port1.addEventListener("message",h)}});let{Atomics:v,Int32Array:w,BigInt64Array:m,postMessage:A}=globalThis;if(!t){const{promise:e,resolve:t}=s(),a=new g(""),i=(e=>{const t=new Map,a=new Map;let n=0;return{resolved:({buffer:e})=>t.get(e),listener(s){if(d(s.data,e.id)){l(s);const{id:e,value:r}=s.data[1],{buffer:n,resolve:o}=a.get(e);a.delete(e),t.delete(n),o(r)}},send(o,i,f){const d=y(i,[],new Set);if(d){const{resolve:o,promise:l}=s(),{buffer:c,path:u}=d;((e,t)=>{let s=t.at(-1);switch(typeof s){case"undefined":case"string":t.push([e]);break;default:r(s)?s.push(e):s.transfer?s.transfer.push(e):s.transfer=[e]}})(c,f),i=[e.id,{id:n,path:u,value:i}],t.set(c,l),a.set(n++,{buffer:c,resolve:o})}o(i,...f)}}})(a);addEventListener("message",(e=>{l(e),a.id=e.data,t()}),{once:!0}),addEventListener("message",(e=>{if(e.ports?.length)for(const t of e.ports){const e=t.postMessage.bind(t);t.start(),t.addEventListener("message",i.listener),o(t,"postMessage",f(((t,...s)=>i.send(e,t,s))))}i.listener(e)})),A=(t,...s)=>{a.id.length?i.send(postMessage,t,s):e.then((()=>i.send(postMessage,t,s)))},v=n(v,{waitAsync:f(((t,s,r,a=1/0)=>({async:!0,value:e.then(c(t,i))})))})}export{v as Atomics,m as BigInt64Array,w as Int32Array,b as MessageChannel,e as SharedArrayBuffer,t as native,A as postMessage};
