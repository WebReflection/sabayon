const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:n}=Array,{create:o,getPrototypeOf:r,values:a}=Object,c=r(Int32Array),i=o(t),f=()=>s.withResolvers();let l=0;const p=new Map,g=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&p.set(this,[l++,0,f()])}},u=new WeakSet,d=new WeakMap,h=e=>(u.add(e),e),y=(e,t)=>{const{data:s}=e,o=n(s)&&(s.at(0)===t||0===s.at(1)&&!t);return o&&(e.stopImmediatePropagation(),e.preventDefault()),o},v=e=>null!==e&&"object"==typeof e&&!u.has(e),w=t=>t instanceof c||t instanceof e,m=new WeakMap,M=(e,t,s)=>{if(p.has(e))t.set(e,p.get(e)[0]);else if(!w(e))for(const n of a(e))v(n)&&!s.has(n)&&(s.add(n),M(n,t,s))};let k=0;const A=(e,t,s)=>{for(const[s,n]of t)m.set(s,[n,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:n,source:o,ports:r},a)=>{e.dispatchEvent(new MessageEvent(t,{data:a,origin:s,lastEventId:n,source:o,ports:r}))})(e,s)},b=(e,t)=>{const s=new Map;return v(t)&&M(t,s,new Set),s.size?[e,2,s,t]:t};let{BigInt64Array:W,Int32Array:I,SharedArrayBuffer:j,SharedWorker:E,Worker:x}=globalThis,D="",P=e=>e,S=!1,{notify:T,waitAsync:_}=i;_||(_=(...e)=>({value:new s((async t=>{const s="/__sabayon_wait_async.js";if(!k){const e=fetch(s,{method:"HEAD"}).then((e=>e.ok),(()=>!1));k=await e?1:-1}const n=new Worker(k<0?"data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))":s);n.onmessage=()=>{n.terminate(),t("ok")},n.postMessage(e)}))})),i.notify=(...e)=>T(...e),i.waitAsync=(...e)=>_(...e);const B=new Map,O=(e,t,s,...n)=>{e.addEventListener(t,s,...n)},R=e=>({...e,type:"module"}),U=e=>{if(y(e,D)){const[t,s,...n]=e.data;switch(s){case 1:((e,t,s)=>{for(const[n,[o,r,{resolve:a}]]of p)if(t===o&&s===r){for(let t=0;t<e.length;t++)n[t]=e[t];const t=d.get(n);t&&(d.delete(n),p.delete(t)),p.delete(n),a("ok");break}})(...n);break;case 2:A(e,...n)}}},L=()=>{if(!D){D=crypto.randomUUID();const[e,t]=[T,_];T=(t,s,...n)=>{const o=(e=>m.get(e))(t);if(o){const[e,n]=o,r=[e,s].join(","),a=B.get(r);return a?a(t):B.set(r,t),n.postMessage([D,1,t,e,s]),0}return e(t,s,...n)},_=(e,...s)=>{if(p.has(e)){const[t,n]=((e,t)=>{const s=p.get(e),[n,o,{promise:r}]=s;return s[1]=t,[n,r]})(e,...s);return{value:n}}return t(e,...s)}}};if(E){const{defineProperties:t,entries:s}=Object,n=e=>{const t=[];for(const[r,a]of s(e))if(v(e)){const s=o(a);s?t.push([r,s]):w(e)||n(a)}for(const[s,n]of t)e[s]=n},o=t=>{if(!p.has(t)&&(t instanceof I||t instanceof W)&&!(t.buffer instanceof e)){const e=t.slice(0),s=[l++,0,f()];return p.set(t,s),p.set(e,s),d.set(t,e),e}},r=(e,t)=>{if(v(t)){const e=o(t);e?t=e:w(t)||n(t)}return b(e,t)};E=class extends E{constructor(e,s){L();const{port:n}=super(e,{name:"sabayon",...R(s)}),o=n.postMessage.bind(n);O(n,"message",U),t(n,{postMessage:{configurable:!0,value:(e,...t)=>o(r(D,e),...t)}}).start(),o([D,0,s])}}}try{new j(4),x=class extends x{constructor(e,t){super(e,R(t))}}}catch(t){P=h,S=!0,L(),j=class extends e{},W=g(W,j),I=g(I,j);const s=({serviceWorker:e},t,s)=>{let n,o=!0;O(e,"message",(e=>{if(y(e,D)){const[t,s,o]=e.data,r=[s,o].join(","),a=e=>{B.delete(r),n.postMessage([D,s,o,e])},c=B.get(r);if(c)a(c);else{const{promise:e,resolve:t}=f();B.set(r,t),e.then(a)}}})),e.getRegistration(t).then((s=>s??e.register(t))).then((function t(r){o=o&&!!e.controller,n=r.installing||r.waiting||r.active,"activated"===n.state?o?s():location.reload():O(n,"statechange",(()=>t(r)),{once:!0})}))};let n=null;x=class extends x{constructor(e,t){let o=t?.serviceWorker||"";if(o){if(o=new URL(o,location.href).href,t={...t,serviceWorker:o},!n){const{promise:e,resolve:t}=f();s(navigator,o,t),n=e}n.then((()=>super.postMessage([D,3])))}super(e,R(t)),super.postMessage([D,0,t]),O(this,"message",U)}postMessage(e,...t){return super.postMessage(b(D,e),...t)}}}export{i as Atomics,W as BigInt64Array,I as Int32Array,j as SharedArrayBuffer,E as SharedWorker,x as Worker,P as ignore,S as polyfill};
