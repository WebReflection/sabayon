let{SharedArrayBuffer:e}=globalThis,t=!0;try{new e(4,{maxByteLength:8})}catch(s){t=!1,e=class extends ArrayBuffer{get growable(){return super.resizable}grow(e){super.resize(e)}}}var s=Promise.withResolvers.bind(Promise);const{ArrayBuffer:r,Atomics:a,Promise:o}=globalThis,{isArray:n}=Array,{create:i,getPrototypeOf:c,values:l}=Object,g=c(Int32Array),p=i(a);let f=0;const u=new Map,d=(e,t)=>class extends e{constructor(e,...r){super(e,...r),e instanceof t&&u.set(this,[f++,0,s()])}},h=new WeakSet,y=e=>(h.add(e),e),w=(e,t)=>{const{data:s}=e,r=n(s)&&(s.at(0)===t||0===s.at(1)&&!t);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r},v=e=>null!==e&&"object"==typeof e&&!h.has(e),m=new WeakMap,A=(e,t,s)=>{if(u.has(e))t.set(e,u.get(e)[0]);else if(!(e instanceof g||e instanceof r))for(const r of l(e))v(r)&&!s.has(r)&&(s.add(r),A(r,t,s))};let k=0;const M=(...e)=>({value:new o((async t=>{const s="/__sabayon_wait_async.js";if(!k){const e=fetch(s,{method:"HEAD"}).then((e=>e.ok),(()=>!1));k=await e?1:-1}const r=new Worker(k<0?"data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))":s);r.onmessage=()=>{r.terminate(),t("ok")},r.postMessage(e)}))}),b=(e,t,s)=>{for(const[s,r]of t)m.set(s,[r,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:r,source:a,ports:o},n)=>{e.dispatchEvent(new MessageEvent(t,{data:n,origin:s,lastEventId:r,source:a,ports:o}))})(e,s)};let{BigInt64Array:I,Int32Array:W,SharedArrayBuffer:E,Worker:j}=globalThis,x=e=>e,B=!t;const D=e=>({...e,type:"module"});if(t)j=class extends j{constructor(e,t){super(e,D(t))}},p.waitAsync||(p.waitAsync=M);else{const t=crypto.randomUUID(),r=new Map,a=(e,t,s,...r)=>{e.addEventListener(t,s,...r)},o=({serviceWorker:e},o,n)=>{let i,c=!0;a(e,"message",(e=>{if(w(e,t)){const[a,o,n]=e.data,c=[o,n].join(","),l=e=>{r.delete(c),i.postMessage([t,o,n,e])},g=r.get(c);if(g)l(g);else{const{promise:e,resolve:t}=s();r.set(c,t),e.then(l)}}})),e.getRegistration(o).then((t=>t??e.register(o))).then((function t(s){c=c&&!!e.controller,i=s.installing||s.waiting||s.active,"activated"===i.state?c?n():location.reload():a(i,"statechange",(()=>t(s)),{once:!0})}))};x=y,p.notify=(e,s)=>{const[a,o]=(e=>m.get(e))(e),n=[a,s].join(","),i=r.get(n);return i?i(e):r.set(n,e),o.postMessage([t,1,e,a,s]),0},p.waitAsync=(e,...t)=>{const[s,r]=((e,t)=>{const s=u.get(e),[r,a,{promise:o}]=s;return s[1]=t,[r,o]})(e,...t);return{value:r}},E=e,I=d(I,E),W=d(W,E);let n=null;j=class extends j{constructor(e,r){let i=r?.serviceWorker||"";if(i){if(i=new URL(i,location.href).href,r={...r,serviceWorker:i},!n){const{promise:e,resolve:t}=s();o(navigator,i,t),n=e}n.then((()=>super.postMessage([t,3])))}super(e,D(r)),super.postMessage([t,0,r]),a(this,"message",(e=>{if(w(e,t)){const[t,s,...r]=e.data;switch(s){case 1:((e,t,s)=>{for(const[r,[a,o,{resolve:n}]]of u)if(t===a&&s===o){r.set(e),u.delete(r),n("ok");break}})(...r);break;case 2:b(e,...r)}}}))}postMessage(e,...s){return super.postMessage(((e,t)=>{const s=new Map;return v(t)&&A(t,s,new Set),s.size?[e,2,s,t]:t})(t,e),...s)}}}export{p as Atomics,I as BigInt64Array,W as Int32Array,E as SharedArrayBuffer,j as Worker,x as ignore,B as polyfill};
