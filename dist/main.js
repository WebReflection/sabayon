const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:r}=Array,{create:n,getPrototypeOf:a,values:o}=Object,c=a(Int32Array),i=n(t),l=()=>s.withResolvers();let f=0;const p=new Map,g=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&p.set(this,[f++,0,l()])}},u=new WeakSet,d=new WeakMap,h=e=>(u.add(e),e),y=(e,t)=>{const{data:s}=e,n=r(s)&&(s.at(0)===t||0===s.at(1)&&!t);return n&&(e.stopImmediatePropagation(),e.preventDefault()),n},v=e=>null!==e&&"object"==typeof e&&!u.has(e),w=t=>t instanceof c||t instanceof e,m=new WeakMap,M=(e,t,s)=>{if(p.has(e))t.set(e,p.get(e)[0]);else if(!w(e))for(const r of o(e))v(r)&&!s.has(r)&&(s.add(r),M(r,t,s))};let k=0;const A=(e,t,s)=>{for(const[s,r]of t)m.set(s,[r,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:r,source:n,ports:a},o)=>{e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:r,source:n,ports:a}))})(e,s)},b=(e,t)=>{const s=new Map;return v(t)&&M(t,s,new Set),s.size?[e,2,s,t]:t};let W,I,{BigInt64Array:j,Int32Array:E,SharedArrayBuffer:x,SharedWorker:D,Worker:P}=globalThis,S=e=>e,T=!1,{notify:_,waitAsync:B}=i;B||(B=(...e)=>({value:new s((async t=>{const s="/__sabayon_wait_async.js";if(!k){const e=fetch(s,{method:"HEAD"}).then((e=>e.ok),(()=>!1));k=await e?1:-1}const r=new Worker(k<0?"data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))":s);r.onmessage=()=>{r.terminate(),t("ok")},r.postMessage(e)}))})),i.notify=(...e)=>_(...e),i.waitAsync=(...e)=>B(...e);const O=(e,t,s,...r)=>{e.addEventListener(t,s,...r)},R=e=>({...e,type:"module"}),U=e=>{if(y(e,W)){const[t,s,...r]=e.data;switch(s){case 1:((e,t,s)=>{for(const[r,[n,a,{resolve:o}]]of p)if(t===n&&s===a){for(let t=0;t<e.length;t++)r[t]=e[t];const t=d.get(r);t&&(d.delete(r),p.delete(t)),p.delete(r),o("ok");break}})(...r);break;case 2:A(e,...r)}}},L=()=>{if(!W){W=crypto.randomUUID(),I=new Map;const[e,t]=[_,B];_=(t,s,...r)=>{const n=(e=>m.get(e))(t);if(n){const[e,r]=n,a=[e,s].join(","),o=I.get(a);return o?o(t):I.set(a,t),r.postMessage([W,1,t,e,s]),0}return e(t,s,...r)},B=(e,...s)=>{if(p.has(e)){const[t,r]=((e,t)=>{const s=p.get(e),[r,n,{promise:a}]=s;return s[1]=t,[r,a]})(e,...s);return{value:r}}return t(e,...s)}}};if(D){const{defineProperties:t,entries:s}=Object,r=(e,t)=>{for(const[r,a]of s(e))e[r]=n(a,t)},n=(e,t)=>{if(v(e)){let s=t.get(e);if(s)return s;if(s=a(e),t.set(e,s||e),s)return s;w(e)||r(e,t)}return e},a=t=>{if(!p.has(t)&&(t instanceof E||t instanceof j)&&!(t.buffer instanceof e)){const e=t.slice(0),s=[f++,0,l()];return p.set(t,s),p.set(e,s),d.set(t,e),e}};D=class extends D{constructor(e,s){L();const{port:r}=super(e,{name:"sabayon",...R(s)}),a=r.postMessage.bind(r);O(r,"message",U),t(r,{postMessage:{configurable:!0,value:(e,...t)=>a(b(W,n(e,new Map)),...t)}}).start(),a([W,0,s])}}}try{new x(4),P=class extends P{constructor(e,t){super(e,R(t))}}}catch(t){S=h,T=!0,L(),x=class extends e{},j=g(j,x),E=g(E,x);const s=({serviceWorker:e},t,s)=>{let r,n=!0;O(e,"message",(e=>{if(y(e,W)){const[t,s,n]=e.data,a=[s,n].join(","),o=e=>{I.delete(a),r.postMessage([W,s,n,e])},c=I.get(a);if(c)o(c);else{const{promise:e,resolve:t}=l();I.set(a,t),e.then(o)}}})),e.getRegistration(t).then((s=>s??e.register(t))).then((function t(a){n=n&&!!e.controller,r=a.installing||a.waiting||a.active,"activated"===r.state?n?s():location.reload():O(r,"statechange",(()=>t(a)),{once:!0})}))};let r=null;P=class extends P{constructor(e,t){let n=t?.serviceWorker||"";if(n){if(n=new URL(n,location.href).href,t={...t,serviceWorker:n},!r){const{promise:e,resolve:t}=l();s(navigator,n,t),r=e}r.then((()=>super.postMessage([W,3])))}super(e,R(t)),super.postMessage([W,0,t]),O(this,"message",U)}postMessage(e,...t){return super.postMessage(b(W,e),...t)}}}export{i as Atomics,j as BigInt64Array,E as Int32Array,x as SharedArrayBuffer,D as SharedWorker,P as Worker,S as ignore,T as polyfill};
