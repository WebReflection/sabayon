const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:a}=Array,{create:r,getPrototypeOf:o,values:n}=Object,i=o(Int32Array),c=r(t),l=()=>s.withResolvers();let g=0;const p=new Map,u=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&p.set(this,[g++,0,l()])}},f=new WeakSet,d=e=>(f.add(e),e),h=(e,t)=>{const{data:s}=e,r=a(s)&&(s.at(0)===t||0===s.at(1)&&!t);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r},v=e=>null!==e&&"object"==typeof e&&!f.has(e),w=new WeakMap,y=(t,s,a)=>{if(p.has(t))s.set(t,p.get(t)[0]);else if(!(t instanceof i||t instanceof e))for(const e of n(t))v(e)&&!a.has(e)&&(a.add(e),y(e,s,a))},m=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),k=(e,t,s)=>{for(const[s,a]of t)w.set(s,[a,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:a,source:r,ports:o},n)=>{e.dispatchEvent(new MessageEvent(t,{data:n,origin:s,lastEventId:a,source:r,ports:o}))})(e,s)};let{BigInt64Array:M,Int32Array:A,SharedArrayBuffer:b,Worker:I}=globalThis,W=e=>e;try{new b(4),c.waitAsync||(c.waitAsync=m)}catch(t){const s=crypto.randomUUID(),a=new Map,r=new Map,o=(e,t,s,...a)=>{e.addEventListener(t,s,...a)},n=e=>r.delete(e),i=({serviceWorker:e},t,a)=>{let i;o(e,"message",(e=>{if(h(e,s)){const[t,a,o]=e.data,c=[a,o].join(","),g=([e,t])=>{n(c),null!==t&&clearTimeout(t),i.postMessage([s,a,o,e])},p=r.get(c);if(p)g(p);else{const{promise:e,resolve:t}=l();r.set(c,t),e.then(g)}}})),e.register(t).then((function e(t){i=t.installing||t.waiting||t.active,"activated"===i.state?a():o(i,"statechange",(()=>e(t)),{once:!0})}))};W=d,c.notify=(e,t)=>{const[a,o]=(e=>w.get(e))(e),i=[a,t].join(","),c=r.get(i);return c?c([e,null]):r.set(i,[e,setTimeout(n,1e3,i)]),o.postMessage([s,1,e,a,t]),0},c.waitAsync=(e,...t)=>{const[s,a]=((e,t)=>{const s=p.get(e),[a,r,{promise:o}]=s;return s[1]=t,[a,o]})(e,...t);return{value:a}},b=class extends e{},M=u(M,b),A=u(A,b),I=class extends I{constructor(e,t={}){let n=t.serviceWorker||"";if(n){if(n=new URL(n,location.href).href,t={...t,serviceWorker:n},!a.has(n)){const{promise:e,resolve:t}=l();i(navigator,n,t),a.set(n,e)}a.get(n).then((()=>super.postMessage([s,3])))}super(e,t),super.postMessage([s,0,t]),o(this,"message",(e=>{if(h(e,s)){const[t,s,...a]=e.data;switch(s){case 1:((e,t,s)=>{for(const[a,[r,o,{resolve:n}]]of p)if(t===r&&s===o){for(let t=0;t<e.length;t++)a[t]=e[t];p.delete(a),n("ok");break}})(...a);break;case 2:k(e,...a);break;case 3:{const e=a.join(","),t=r.get(e);t&&clearTimeout(t[1]);break}}}}))}postMessage(e,...t){return super.postMessage(((e,t)=>{const s=new Map;return v(t)&&y(t,s,new Set),s.size?[e,2,s,t]:t})(s,e),...t)}}}export{c as Atomics,M as BigInt64Array,A as Int32Array,b as SharedArrayBuffer,I as Worker,W as ignore};
