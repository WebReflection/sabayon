const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:a}=Array,{create:r,getPrototypeOf:o,values:n}=Object,c=o(Int32Array),i=r(t),l=()=>s.withResolvers();let p=0;const g=new Map,d=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&g.set(this,[p++,0,l()])}},f=new WeakSet,u=e=>(f.add(e),e),h=(e,t)=>{const{data:s}=e,r=a(s)&&(s.at(0)===t||0===s.at(1)&&!t);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r},v=e=>null!==e&&"object"==typeof e&&!f.has(e),m=new WeakMap,y=(t,s,a)=>{if(g.has(t))s.set(t,g.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of n(t))v(e)&&!a.has(e)&&(a.add(e),y(e,s,a))};let w=0;const M=(...e)=>({value:new s((async t=>{const s="/__sabayon_wait_async.js";if(!w){const e=fetch(s,{method:"HEAD"}).then((e=>e.ok),(()=>!1));w=await e?1:-1}const a=new Worker(w<0?"data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))":s);a.onmessage=()=>{a.terminate(),t("ok")},a.postMessage(e)}))}),k=(e,t,s)=>{for(const[s,a]of t)m.set(s,[a,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:a,source:r,ports:o},n)=>{e.dispatchEvent(new MessageEvent(t,{data:n,origin:s,lastEventId:a,source:r,ports:o}))})(e,s)},A=(e,t)=>{const s=new Map;return v(t)&&y(t,s,new Set),s.size?[e,2,s,t]:t};let{BigInt64Array:b,Int32Array:I,SharedArrayBuffer:W,SharedWorker:j,Worker:E}=globalThis,x=e=>e,D=!1;const P=e=>({...e,type:"module"});try{new W(4);const e=e=>class extends e{constructor(e,t){super(e,P(t))}};j&&(j=e(j)),E=e(E),i.waitAsync||(i.waitAsync=M)}catch(t){const s=crypto.randomUUID(),{defineProperties:a}=Object,r=new Map,o={once:!0},n=(e,t,s,...a)=>{e.addEventListener(t,s,...a)},c=({serviceWorker:e},t,a)=>{let c,i=!0;n(e,"message",(e=>{if(h(e,s)){const[t,a,o]=e.data,n=[a,o].join(","),i=e=>{r.delete(n),c.postMessage([s,a,o,e])},p=r.get(n);if(p)i(p);else{const{promise:e,resolve:t}=l();r.set(n,t),e.then(i)}}})),e.getRegistration(t).then((s=>s??e.register(t))).then((function t(s){i=i&&!!e.controller,c=s.installing||s.waiting||s.active,"activated"===c.state?i?a():location.reload():n(c,"statechange",(()=>t(s)),o)}))};x=u,D=!0,i.notify=(e,t)=>{const[a,o]=(e=>m.get(e))(e),n=[a,t].join(","),c=r.get(n);return c?c(e):r.set(n,e),o.postMessage([s,1,e,a,t]),0},i.waitAsync=(e,...t)=>{const[s,a]=((e,t)=>{const s=g.get(e),[a,r,{promise:o}]=s;return s[1]=t,[a,o]})(e,...t);return{value:a}},W=class extends e{},b=d(b,W),I=d(I,W);const p=e=>{if(h(e,s)){const[t,s,...a]=e.data;switch(s){case 1:((e,t,s)=>{for(const[a,[r,o,{resolve:n}]]of g)if(t===r&&s===o){for(let t=0;t<e.length;t++)a[t]=e[t];g.delete(a),n("ok");break}})(...a);break;case 2:k(e,...a)}}};let f=null;j&&(j=class extends j{constructor(e,t){const{port:r}=super(e,P(t)),{promise:c,resolve:i}=l(),g=r.postMessage.bind(r);n(r,"message",(e=>{e.stopImmediatePropagation(),g([s,0,t]),i()}),o),n(r,"message",p),a(r,{postMessage:{configurable:!0,value:(e,...t)=>{c.then((()=>g(A(s,e),...t)))}}}).start()}}),E=class extends E{constructor(e,t){let a=t?.serviceWorker||"";if(a){if(a=new URL(a,location.href).href,t={...t,serviceWorker:a},!f){const{promise:e,resolve:t}=l();c(navigator,a,t),f=e}f.then((()=>super.postMessage([s,3])))}super(e,P(t)),super.postMessage([s,0,t]),n(this,"message",p)}postMessage(e,...t){return super.postMessage(A(s,e),...t)}}}export{i as Atomics,b as BigInt64Array,I as Int32Array,W as SharedArrayBuffer,j as SharedWorker,E as Worker,x as ignore,D as polyfill};
