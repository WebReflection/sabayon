const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:a}=Array,{create:r,getPrototypeOf:n,values:o}=Object,c=n(Int32Array),i=r(t),l=({currentTarget:e,type:t,origin:s,lastEventId:a,source:r,ports:n},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:a,source:r,ports:n})),p=()=>s.withResolvers();let f=0;const u=new Map,g=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&u.set(this,[f++,0,p()])}},d=new WeakSet,y=e=>(d.add(e),e),w=e=>null!==e&&"object"==typeof e&&!d.has(e),v=new WeakMap,h=(t,s,a)=>{if(u.has(t))s.set(t,u.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of o(t))w(e)&&!a.has(e)&&(a.add(e),h(e,s,a))},A=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),k=(e,t)=>{const s=u.get(e),[a,r,{promise:n}]=s;return s[1]=t,[a,n]};let{BigInt64Array:m,Int32Array:b,SharedArrayBuffer:I,addEventListener:T,postMessage:E}=globalThis,M=!0,j=e=>e,P=!1;const S=p();try{new I(4),i.waitAsync||(i.waitAsync=A),S.resolve()}catch(t){const s=E,r=T,n=[];let o="",c="";I=class extends e{},m=g(m,I),b=g(b,I),j=y,P=!0,i.notify=(e,t)=>{const[a]=(e=>v.get(e))(e);return s([o,1,e,a,t]),0},i.waitAsync=(...e)=>{const[t,s]=k(...e);return{value:s}},i.wait=(e,t,...s)=>{const[a]=k(e,t,...s),r=new XMLHttpRequest;r.responseType="json",r.open("POST",`${c}?sabayon`,!1),r.setRequestHeader("Content-Type","application/json"),r.send(`["${o}",${a},${t}]`);const{response:n}=r;u.delete(e);for(let t=0;t<n.length;t++)e[t]=n[t];return"ok"},r("message",(e=>{if(((e,t)=>{const{data:s}=e,r=a(s)&&(s.at(0)===t||0===s.at(1)&&!t);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r})(e,o)){const[t,s,...a]=e.data;switch(s){case 0:o=t,c=a.at(0)?.serviceWorker||"",c||(i.wait=null,S.resolve());break;case 1:((e,t,s)=>{for(const[a,[r,n,{resolve:o}]]of u)if(t===r&&s===n){for(let t=0;t<e.length;t++)a[t]=e[t];u.delete(a),o("ok");break}})(...a);break;case 2:((e,t,s)=>{for(const[s,a]of t)v.set(s,[a,e.currentTarget]);l(e,s)})(e,...a);break;case 3:S.resolve()}}else if(M){const{currentTarget:t,type:s,origin:a,lastEventId:r,source:o,ports:c}=e;n.push([{currentTarget:t,type:s,origin:a,lastEventId:r,source:o,ports:c},e.data])}})),T=(e,...t)=>{if(r(e,...t),n.length)for(const e of n.splice(0))l(...e)},E=(e,...t)=>s(((e,t)=>{const s=new Map;return w(t)&&h(t,s,new Set),s.size?[e,2,s,t]:t})(o,e),...t)}await S.promise,M=!1;export{i as Atomics,m as BigInt64Array,b as Int32Array,I as SharedArrayBuffer,T as addEventListener,j as ignore,P as polyfill,E as postMessage};
