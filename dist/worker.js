const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:a}=Array,{create:r,getPrototypeOf:o,values:n}=Object,c=o(Int32Array),i=r(t),l=({currentTarget:e,type:t,origin:s,lastEventId:a,source:r,ports:o},n)=>e.dispatchEvent(new MessageEvent(t,{data:n,origin:s,lastEventId:a,source:r,ports:o})),p=()=>s.withResolvers();let f=0;const g=new Map,u=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&g.set(this,[f++,0,p()])}},d=new WeakSet,y=e=>(d.add(e),e),w=e=>null!==e&&"object"==typeof e&&!d.has(e),v=new WeakMap,h=(t,s)=>{if(g.has(t))s.set(t,g.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of n(t))w(e)&&h(e,s)},A=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),k=(e,t)=>{const s=g.get(e),[a,r,{promise:o}]=s;return s[1]=t,[a,o]};let{Int32Array:m,SharedArrayBuffer:b,addEventListener:M,postMessage:T}=globalThis,E=e=>e,I=!0;const j=p();try{new b(4),i.waitAsync||(i.waitAsync=A),j.resolve()}catch(t){const{stringify:s,parse:r}=JSON,o=T,n=M,c=[];let p="",f="";b=class extends e{},m=u(m,b),E=y,i.notify=(e,t)=>{const[s]=(e=>v.get(e))(e);return o([p,1,e,s,t]),0},i.waitAsync=(...e)=>{const[t,s]=k(...e);return{value:s}},i.wait=(e,t,...a)=>{const[n]=k(e,t,...a);o([p,3,n,t]);const c=new XMLHttpRequest;c.open("POST",`${f}?sabayon`,!1),c.setRequestHeader("Content-Type","application/json"),c.send(s([p,n,t]));const i=r(c.responseText);g.delete(e);for(let t=0;t<i.length;t++)e[t]=i[t];return"ok"},n("message",(e=>{if(((e,t)=>{const{data:s}=e,r=a(s)&&(s.at(0)===t||0===s.at(1)&&!t);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r})(e,p)){const[t,s,...a]=e.data;switch(s){case 0:p=t,f=a.at(0)?.serviceWorker||"",f||j.resolve();break;case 1:((e,t,s)=>{for(const[a,[r,o,{resolve:n}]]of g)if(t===r&&s===o){for(let t=0;t<e.length;t++)a[t]=e[t];g.delete(a),n("ok");break}})(...a);break;case 2:{const[t,s]=a;((e,t,s)=>{for(const[s,a]of t)v.set(s,[a,e.currentTarget]);l(e,s)})(e,t,s),I&&c.push([e,s]);break}case 3:j.resolve()}}})),M=(e,...t)=>{if(n(e,...t),"message"===e)for(const e of c.splice(0))l(...e)},T=(e,...t)=>o(((e,t)=>{const s=new Map;return w(t)&&h(t,s),s.size?[e,2,s,t]:t})(p,e),...t)}await j.promise,I=!1;export{i as Atomics,m as Int32Array,b as SharedArrayBuffer,M as addEventListener,E as ignore,T as postMessage};
