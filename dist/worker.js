const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:r}=Array,{create:a,getPrototypeOf:n,values:o}=Object,c=n(Int32Array),i=a(t),l=({currentTarget:e,type:t,origin:s,lastEventId:r,source:a,ports:n},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:r,source:a,ports:n})),p=()=>s.withResolvers();let f=0;const g=new Map,u=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&g.set(this,[f++,0,p()])}},d=new WeakSet,y=e=>(d.add(e),e),w=e=>null!==e&&"object"==typeof e&&!d.has(e),v=new WeakMap,h=(t,s,r)=>{if(g.has(t))s.set(t,g.get(t)[0]);else if(!(t instanceof c||t instanceof e))for(const e of o(t))w(e)&&!r.has(e)&&(r.add(e),h(e,s,r))},A=(...e)=>({value:new s((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),k=(e,t)=>{const s=g.get(e),[r,a,{promise:n}]=s;return s[1]=t,[r,n]};let{BigInt64Array:m,Int32Array:b,SharedArrayBuffer:E,addEventListener:I,postMessage:T}=globalThis,M=e=>e,S=!0;const j=p();try{new E(4),i.waitAsync||(i.waitAsync=A),j.resolve()}catch(t){const{stringify:s}=JSON,a=T,n=I,o=[];let c="",p="";E=class extends e{},m=u(m,E),b=u(b,E),M=y,i.notify=(e,t)=>{const[s]=(e=>v.get(e))(e);return a([c,1,e,s,t]),0},i.waitAsync=(...e)=>{const[t,s]=k(...e);return{value:s}},i.wait=(e,t,...r)=>{if(!p)throw new SyntaxError("Atomics.wait requires a Service Worker");const[a]=k(e,t,...r),n=new XMLHttpRequest;n.responseType="json",n.open("POST",`${p}?sabayon`,!1),n.setRequestHeader("Content-Type","application/json"),n.send(s([c,a,t]));const{response:o}=n;g.delete(e);for(let t=0;t<o.length;t++)e[t]=o[t];return"ok"},n("message",(e=>{if(((e,t)=>{const{data:s}=e,a=r(s)&&(s.at(0)===t||0===s.at(1)&&!t);return a&&(e.stopImmediatePropagation(),e.preventDefault()),a})(e,c)){const[t,s,...r]=e.data;switch(s){case 0:c=t,p=r.at(0)?.serviceWorker||"",p||j.resolve();break;case 1:((e,t,s)=>{for(const[r,[a,n,{resolve:o}]]of g)if(t===a&&s===n){for(let t=0;t<e.length;t++)r[t]=e[t];g.delete(r),o("ok");break}})(...r);break;case 2:((e,t,s)=>{for(const[s,r]of t)v.set(s,[r,e.currentTarget]);l(e,s)})(e,...r);break;case 3:j.resolve()}}else if(S){const{currentTarget:t,type:s,origin:r,lastEventId:a,source:n,ports:c}=e;o.push([{currentTarget:t,type:s,origin:r,lastEventId:a,source:n,ports:c},e.data])}})),I=(e,...t)=>{if(n(e,...t),o.length)for(const e of o.splice(0))l(...e)},T=(e,...t)=>a(((e,t)=>{const s=new Map;return w(t)&&h(t,s,new Set),s.size?[e,2,s,t]:t})(c,e),...t)}await j.promise,S=!1;export{i as Atomics,m as BigInt64Array,b as Int32Array,E as SharedArrayBuffer,I as addEventListener,M as ignore,T as postMessage};
