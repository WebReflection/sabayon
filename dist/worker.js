let e=0;const t=e++,s=e++,a=e++,r=e++,{ArrayBuffer:n,Atomics:o,Promise:c}=globalThis,{isArray:i}=Array,{create:l,getPrototypeOf:p,values:f}=Object,g=p(Int32Array),u=l(o),d=({currentTarget:e,type:t,origin:s,lastEventId:a,source:r,ports:n},o)=>e.dispatchEvent(new MessageEvent(t,{data:o,origin:s,lastEventId:a,source:r,ports:n})),y=()=>c.withResolvers(),w=new Map,v=(t,s)=>class extends t{constructor(t,...a){super(t,...a),t instanceof s&&w.set(this,[e++,0,y()])}},h=new WeakSet,A=e=>(h.add(e),e),k=e=>null!==e&&"object"==typeof e&&!h.has(e),m=new WeakMap,b=(e,t,s)=>{if(w.has(e))t.set(e,w.get(e)[0]);else if(!(e instanceof g||e instanceof n))for(const a of f(e))k(a)&&!s.has(a)&&(s.add(a),b(a,t,s))},I=(...e)=>({value:new c((t=>{let s=new Worker("data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))");s.onmessage=()=>t("ok"),s.postMessage(e)}))}),T=(e,t)=>{const s=w.get(e),[a,r,{promise:n}]=s;return s[1]=t,[a,n]};let{BigInt64Array:E,Int32Array:M,SharedArrayBuffer:j,addEventListener:S,postMessage:O}=globalThis,P=e=>e,W=!0;const x=y();try{new j(4),u.waitAsync||(u.waitAsync=I),x.resolve()}catch(e){const{stringify:o}=JSON,c=O,l=S,p=[];let f="",g="";j=class extends n{},E=v(E,j),M=v(M,j),P=A,u.notify=(e,t)=>{const[a]=(e=>m.get(e))(e);return c([f,s,e,a,t]),0},u.waitAsync=(...e)=>{const[t,s]=T(...e);return{value:s}},u.wait=(e,t,...s)=>{const[a]=T(e,t,...s),r=new XMLHttpRequest;r.responseType="json",r.open("POST",`${g}?sabayon`,!1),r.setRequestHeader("Content-Type","application/json"),r.send(o([f,a,t]));const{response:n}=r;w.delete(e);for(let t=0;t<n.length;t++)e[t]=n[t];return"ok"},l("message",(e=>{if(((e,s)=>{const{data:a}=e,r=i(a)&&(a.at(0)===s||a.at(1)===t&&!s);return r&&(e.stopImmediatePropagation(),e.preventDefault()),r})(e,f)){const[n,o,...c]=e.data;switch(o){case t:f=n,g=c.at(0)?.serviceWorker||"",g||(u.wait=null,x.resolve());break;case s:((e,t,s)=>{for(const[a,[r,n,{resolve:o}]]of w)if(t===r&&s===n){for(let t=0;t<e.length;t++)a[t]=e[t];w.delete(a),o("ok");break}})(...c);break;case a:((e,t,s)=>{for(const[s,a]of t)m.set(s,[a,e.currentTarget]);d(e,s)})(e,...c);break;case r:x.resolve()}}else if(W){const{currentTarget:t,type:s,origin:a,lastEventId:r,source:n,ports:o}=e;p.push([{currentTarget:t,type:s,origin:a,lastEventId:r,source:n,ports:o},e.data])}})),S=(e,...t)=>{if(l(e,...t),p.length)for(const e of p.splice(0))d(...e)},O=(e,...t)=>c(((e,t)=>{const s=new Map;return k(t)&&b(t,s,new Set),s.size?[e,a,s,t]:t})(f,e),...t)}await x.promise,W=!1;export{u as Atomics,E as BigInt64Array,M as Int32Array,j as SharedArrayBuffer,S as addEventListener,P as ignore,O as postMessage};
