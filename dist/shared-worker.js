const{ArrayBuffer:e,Atomics:t,Promise:s}=globalThis,{isArray:a}=Array,{create:n,getPrototypeOf:o,values:r}=Object,c=o(Int32Array),i=n(t),l=()=>s.withResolvers();let f=0;const p=new Map,d=(e,t)=>class extends e{constructor(e,...s){super(e,...s),e instanceof t&&p.set(this,[f++,0,l()])}},g=new WeakSet,u=new WeakMap,w=(e,t)=>{const{data:s}=e,n=a(s)&&(s.at(0)===t||0===s.at(1)&&!t);return n&&(e.stopImmediatePropagation(),e.preventDefault()),n},y=e=>null!==e&&"object"==typeof e&&!g.has(e),h=new WeakMap,v=(t,s,a)=>{if(p.has(t))s.set(t,p.get(t)[0]);else if(!(t=>t instanceof c||t instanceof e)(t))for(const e of r(t))y(e)&&!a.has(e)&&(a.add(e),v(e,s,a))};let A=0;const m=(e,t,s)=>{for(const[a,[n,o,{resolve:r}]]of p)if(t===n&&s===o){for(let t=0;t<e.length;t++)a[t]=e[t];const t=u.get(a);t&&(u.delete(a),p.delete(t)),p.delete(a),r("ok");break}},b=(e,t,s)=>{for(const[s,a]of t)h.set(s,[a,e.currentTarget]);(({currentTarget:e,type:t,origin:s,lastEventId:a,source:n,ports:o},r)=>{e.dispatchEvent(new MessageEvent(t,{data:r,origin:s,lastEventId:a,source:n,ports:o}))})(e,s)},k=(e,t)=>{const s=new Map;return y(t)&&v(t,s,new Set),s.size?[e,2,s,t]:t};let{BigInt64Array:M,Int32Array:E,SharedArrayBuffer:I}=globalThis;const j=e=>(g.add(e),e),W=!0;i.waitAsync||(i.waitAsync=(...e)=>({value:new s((async t=>{const s="/__sabayon_wait_async.js";if(!A){const e=fetch(s,{method:"HEAD"}).then((e=>e.ok),(()=>!1));A=await e?1:-1}const a=new Worker(A<0?"data:application/javascript,onmessage%3De%3D%3EpostMessage(!Atomics.wait(...e.data))":s);a.onmessage=()=>{a.terminate(),t("ok")},a.postMessage(e)}))}));const{defineProperties:D}=Object,P=new WeakMap;addEventListener("connect",(({ports:e})=>{for(const t of e){let e="";const{promise:s,resolve:a}=l(),n=t.postMessage.bind(t);t.addEventListener("message",(s=>{if(w(s,e)){const[o,r,...c]=s.data;switch(r){case 0:e=o,P.set(t,[e,n]),a();break;case 1:m(...c);break;case 2:b(s,...c)}}})),D(t,{postMessage:{configurable:!0,value:(t,...a)=>{s.then((()=>n(k(e,t),...a)))}}}).start()}})),I=class extends e{},M=d(M,I),E=d(E,I),i.notify=(e,t)=>{const[s,a]=(e=>h.get(e))(e),[n,o]=P.get(a);return o([n,1,e,s,t]),0},i.waitAsync=(...e)=>{const[t,s]=((e,t)=>{const s=p.get(e),[a,n,{promise:o}]=s;return s[1]=t,[a,o]})(...e);return{value:s}};export{i as Atomics,M as BigInt64Array,E as Int32Array,I as SharedArrayBuffer,j as ignore,W as polyfill};
